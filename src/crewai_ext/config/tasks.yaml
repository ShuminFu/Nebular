intent_analysis_task:
  description: >
    分析以下对话的意图，判断是否是有意义的对话：

    对话信息：
    1. 内容：{text}
    2. 类型：{type}
    3. 是否为旁白：{is_narratage}
    4. 是否为悄悄话：{is_whisper}
    5. 标签：{tags}
    6. 是否提及其他Staff：{mentioned_staff_bools}

    要求如下：
    1. 首先判断对话是否有实质内容：
        - 是否包含明确的意图或目的
        - 是否需要响应或处理
        - 是否包含实质性的内容
        - 如果是纯粹的表情、语气词或无意义的重复，返回空字符串作为意图

    2. 如果对话有意义：
        - 用一句简洁的话描述意图
        - 包含关键动作和目标
        - 如果是工具调用，说明调用的工具
        - 如果是任务相关，说明任务类型

    3. 如果是代码生成请求：
        - 说明需要生成的代码类型（如Python, HTML, CSS等）
        - 描述代码的用途和功能
        - 列出关键需求和约束
        - 标注是否需要特定的框架或库
        - 识别需要生成的所有文件
        - 确定每个文件的类型和用途
        - 识别文件之间的关联（如HTML引用CSS和JS）
        - 确定项目的整体结构
        - is_code_request字段返回true
    4. 如果是已经生成了代码：
        - 比如parameters的text字段中已经生成了代码或者其他资源，则is_code_request字段返回false
        - 根据生成的代码中parameters的text字段中的头部信息获取file_path和mime_type用于返回的code_details.resources里。
  expected_output: |
    返回格式为JSON对象，示例如下：
    {{
        "intent": "意图描述，无意义对话则返回空字符串",
        "reason": "如果intent为空，说明原因",
        "is_code_request": true/false,
        "code_details": {{
            "project_type": "web/python/java等项目类型",
            "project_description": "项目整体描述",
            "resources": [
                {{
                    "file_path": "version_{timestamp}/src/html/index.html",
                    "type": "html",
                    "mime_type": "text/html",
                    "description": "主页面文件",
                    "references": ["style.css", "main.js"]
                }},
                {{
                    "file_path": "version_{timestamp}/src/css/style.css",
                    "type": "css",
                    "mime_type": "text/css",
                    "description": "样式文件"
                }},
                {{
                    "file_path": "version_{timestamp}/src/js/main.js",
                    "type": "javascript",
                    "mime_type": "text/javascript",
                    "description": "交互脚本"
                }}
            ],
            "requirements": ["需求1", "需求2"],
            "frameworks": ["react", "vue", "@popperjs/core", "normalize.css"]
        }}
    }}
  agent: intent_analyzer

index_task:
  description: >
    不使用工具，分析以下对话的上下文关联，关注代码生成相关的上下文：

    当前对话：
    - Opera ID: {opera_id}
    - 索引：{dialogue_index}
    - 内容：{text}
    - 类型：{type}
    - 标签：{tags}
    - 阶段：{stage_index}
    同阶段的对话：
    {dialogue_same_stage}

    分析要求：
    1. 识别相关的代码讨论
    2. 跟踪代码需求的变化
    3. 关联代码生成的上下文
    4. 考虑时序关系
    5. 分析对话意图的关联
    6. 优先关联同一阶段的对话

    返回格式：逗号分隔的相关对话索引列表。如果没有相关对话，返回空字符串。
  expected_output: "逗号分隔的相关对话DialogueIndex列表，例如：1,2,3"
  agent: context_analyzer

context_structure_task:
  description: |
    使用对话工具的get action来分析相关对话并生成结构化的上下文数据：

    当前对话：
    - Opera ID: {opera_id}
    - 索引：{dialogue_index}
    - 内容：{text}
    - 类型：{type}
    - 标签：{tags}
    - 意图：{intent_analysis}

    相关对话：基于前一个任务得到的索引列表

    分析要求：
    1. 提取对话主题和关键信息
    2. 识别对话流程和状态变化
    3. 跟踪重要的上下文变量
    4. 记录关键的决策点
    5. 特别关注代码生成相关的上下文：
      - 代码需求的演变
      - API和框架的选择
      - 文件结构的变化
      - 重要的配置决定
    6. 主题定义规则：
        1. 主题独立性：
        - 每个主题代表一个明确的目标或需求
        - 当需求发生变更时，应创建新主题
        - 新主题应该关联到源主题
        - 必要的时候使用UUIDGeneratorTool工具创建UUID来创建主题

        2. 变更判断标准：
        - 功能需求的重大改变
        - 架构或设计的显著调整
        - 技术栈或依赖的变更
        - 与原主题目标的显著偏离

        3. 主题状态：
        - active: 当前正在处理的主题
        - completed: 已完成的主题
        - superseded: 被新主题取代的主题
  expected_output: |
    返回格式为JSON对象，包含对话流程、代码上下文和决策点信息
  agent: context_analyzer